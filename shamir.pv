free c: channel.
free secretChannel: channel [private].

type xCoor.
type yCoor.
type point.

free one : xCoor.
free two : xCoor.
free three : xCoor.
free four : xCoor.

fun reconstruct(yCoor, yCoor, yCoor, yCoor): bitstring.

fun f(xCoor) : yCoor [private].
fun toPoint(xCoor, yCoor) : point.

reduc forall x: xCoor, y: yCoor; fromPointToY(toPoint(x, y)) = y.

(*reduc forall x: bitstring, y: bitstring, z: bitstring, v: bitstring; split1(x, y ,z) = reconstruct(x,y,z,v).*)
event secretSharingEnded(bitstring).
event secretSharingStarted(bitstring).
event reach.

query event (reach).
query attacker (f(one)).
query attacker (f(two)).
query attacker (f(three)).
query attacker (f(four)).
query attacker (reconstruct(f(one), f(two), f(three), f(four))).

table shares(yCoor).
(*query x: bitstring, y: bitstring, z: bitstring, v: bitstring; event (secretSharingEnded(reconstructFull(x,y,z,v))) ==> event (secretSharingStarted (reconstructFull(x,y,z,v))). *)

let adversary (share : yCoor) =
    out(c, share);
    0.

let participant (share : yCoor) =
  0.

let attackerCombine =
  in(c, share_one : yCoor);
  in(c, share_two : yCoor);
  in(c, share_three : yCoor);
  if(share_one <> share_two && share_two <> share_three && share_one <> share_three) then
  get shares(x: yCoor) suchthat x = share_one in
  get shares(y: yCoor) suchthat y = share_two in
  get shares(z: yCoor) suchthat z = share_three in

  in(secretChannel, s : bitstring);
  event reach();
  out(c, s).



process
  let xPoint = f(one) in
  let yPoint = f(two) in
  let zPoint = f(three) in
  let vPoint = f(four) in
  insert shares(xPoint);
  insert shares(yPoint);
  insert shares(zPoint);
  insert shares(vPoint);
  !attackerCombine |
  let s = reconstruct(xPoint, yPoint, zPoint, vPoint) in
  (!out(secretChannel, s)) |
  participant (xPoint) | participant (yPoint) | participant (zPoint) | participant (vPoint) | adversary(xPoint) | adversary(yPoint) | adversary(zPoint)
(*  event secretSharingStarted (reconstructFull(x,y,z,v)); *)
